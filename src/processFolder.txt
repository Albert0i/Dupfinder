// processFolder.js
// Stage 1: Scan folder recursively, generate SHA-256 hashes, and record metadata.
// Includes ignore list, extension filter, and logging for skipped entries.

import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import crypto from 'crypto';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';

const DB_PATH = './data/db.sq3';
const BATCH_SIZE = 1000;
let batch = [];
let processedCount = 0;
let skippedCount = 0;
const startTime = Date.now();

// üß≠ Get folder path from command-line argument
const ROOT_FOLDER = process.argv[2];
if (!ROOT_FOLDER) {
  console.error('‚ùå Please provide a folder path.\nUsage: node processFolder.js <folder_path>');
  process.exit(1);
}

// üõ°Ô∏è Ignore list: folders/files to skip by name
const ignoreList = [
  'node_modules',
  '__pycache__',
  '.git',
  '.svn',
  '.DS_Store',
  'Thumbs.db',
  'desktop.ini',
  '$Recycle.Bin',
  'System Volume Information',
  'Program Files',
  'Program Files (x86)',
  'Windows',
  'AppData',
  'Local Settings',
  'Recovery',
  'PerfLogs',
  'Temp',
  'Tmp', 
  'cache',
  'Cache', 
  '__MACOSX',
  '.Spotlight-V100',
  '.Trashes',
  'ehthumbs.db',
  'pagefile.sys',
  'hiberfil.sys',
  'swapfile.sys'
];

// üõ°Ô∏è Ignore extensions: skip files with these suffixes
const ignoreExtensions = ['.aof', '.incr.aof'];

// üîç Check if file is hidden (starts with . or $)
async function isHidden(filePath) {
  try {
    const stats = await fs.lstat(filePath);
    const name = path.basename(filePath);
    return name.startsWith('.') || (stats.mode & 0o100000 && name.startsWith('$'));
  } catch {
    return false;
  }
}

// üîê Generate SHA-256 hash of file contents
async function hashFile(filePath) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('sha256');
    const stream = fsSync.createReadStream(filePath);
    stream.on('data', chunk => hash.update(chunk));
    stream.on('end', () => resolve(hash.digest('hex')));
    stream.on('error', reject);
  });
}

// üß≠ Recursively walk through folder and yield file paths
async function* walk(dir) {
  try {
    const dirHandle = await fs.opendir(dir);
    for await (const entry of dirHandle) {
      const fullPath = path.join(dir, entry.name);

      if (ignoreList.includes(entry.name)) {
        console.log(`üõ°Ô∏è Ignored: ${fullPath}`);
        continue;
      }

      if (await isHidden(fullPath)) continue;

      try {
        const stat = await fs.lstat(fullPath);
        if (stat.isDirectory()) {
          yield* walk(fullPath);
        } else if (stat.isFile()) {
          const ext = path.extname(entry.name).toLowerCase();
          if (ignoreExtensions.includes(ext)) {
            console.log(`üõ°Ô∏è Ignored extension: ${fullPath}`);
            continue;
          }
          if (stat.size === 0) {
            console.log(`üõ°Ô∏è Ignored empty file: ${fullPath}`);
            continue;
          }
          yield fullPath;
        }
      } catch {
        continue;
      }
    }
  } catch (err) {
    if (err.code === 'EPERM' || err.code === 'EACCES') {
      console.warn(`üö´ Skipped protected folder: ${dir}`);
    } else {
      console.error(`‚ö†Ô∏è Error accessing ${dir}:`, err.message);
    }
  }
}

// üßæ Flush batch into database, handle constraint violations
async function flushBatch(db, insertStmt, updateStmt) {
  if (batch.length === 0) return;
  try {
    await db.exec('BEGIN TRANSACTION');
    for (const item of batch) {
      try {
        await insertStmt.run(
          item.fileName,
          item.fullPath,
          item.fileFormat,
          item.fileSize,
          item.hash,
          item.createdAt,
          item.modifiedAt
        );
        processedCount++;
      } catch (err) {
        if (err.code === 'SQLITE_CONSTRAINT') {
          await updateStmt.run(item.fullPath);
          skippedCount++;
        } else {
          throw err;
        }
      }
    }
    await db.exec('COMMIT');
    console.log(`üì¶ Batch flushed: ${batch.length} items`);
    batch = [];
  } catch (err) {
    console.error('‚ö†Ô∏è Error during flushBatch:', err.message);
  }
}

// üß¨ Process individual file and add to batch
async function processFile(filePath, db, insertStmt, updateStmt) {
  try {
    const stat = await fs.stat(filePath);
    const hash = await hashFile(filePath);
    const fileName = path.basename(filePath);
    const fileFormat = path.extname(filePath).slice(1).toLowerCase();
    const fileSize = stat.size;
    const createdAt = stat.birthtime.toISOString();
    const modifiedAt = stat.mtime.toISOString();

    batch.push({
      fileName,
      fullPath: filePath,
      fileFormat,
      fileSize,
      hash,
      createdAt,
      modifiedAt
    });

    if (batch.length >= BATCH_SIZE) {
      await flushBatch(db, insertStmt, updateStmt);
    }
  } catch (err) {
    console.error(`‚ö†Ô∏è Error processing ${filePath}:`, err.message);
  }
}

// üß± Main ritual: setup DB, scan folder, insert records
async function main() {
  await fs.mkdir('./data', { recursive: true });
  const db = await open({ filename: DB_PATH, driver: sqlite3.Database });

  // üßæ Create table if not exists
  await db.exec(`
    CREATE TABLE IF NOT EXISTS files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      fileName VARCHAR(128) NOT NULL,
      fullPath VARCHAR(255) NOT NULL,
      fileFormat VARCHAR(16) NOT NULL,
      fileSize INTEGER NOT NULL,
      hash CHAR(64) NOT NULL,
      createdAt VARCHAR(24) NOT NULL,
      modifiedAt VARCHAR(24) NOT NULL,
      updateIdent INTEGER NOT NULL DEFAULT 0,
      UNIQUE(fullPath)
    );
  `);

  const insertStmt = await db.prepare(`
    INSERT INTO files (fileName, fullPath, fileFormat, fileSize, hash, createdAt, modifiedAt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `);

  const updateStmt = await db.prepare(`
    UPDATE files SET updateIdent = updateIdent + 1 WHERE fullPath = ?
  `);

  for await (const filePath of walk(ROOT_FOLDER)) {
    await processFile(filePath, db, insertStmt, updateStmt);
  }
  /*
  // JavaScript does this under the hood:

  const iterator = walk(ROOT_FOLDER)[Symbol.asyncIterator]();
  let result = await iterator.next();
  while (!result.done) {
    const filePath = result.value;
    await processFile(filePath, db, insertStmt, updateStmt);
    result = await iterator.next();
  }
  */

  await flushBatch(db, insertStmt, updateStmt);
  await insertStmt.finalize();
  await updateStmt.finalize();
  await db.close();

  // üßÆ Final report
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
  console.log(`\n‚úÖ Scan complete.`);
  console.log(`‚è±Ô∏è Elapsed time: ${elapsed} seconds`);
  console.log(`üìÅ Files processed: ${processedCount}`);
  console.log(`‚ö†Ô∏è Files skipped (constraint violation): ${skippedCount}`);
}

main();

/*
   node src/deduplicate.js "D:\RU\RUImages"

   npm run process -- d:\
   npm run process -- D:\RU\RUImages
*/